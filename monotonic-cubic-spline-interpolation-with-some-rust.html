<!DOCTYPE html>
<head>
        <meta http-equiv="Content-Type" content="text/html; charset=utf-8">
        <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.12.0/dist/katex.min.css" integrity="sha384-AfEj0r4/OFrOo5t7NnNe46zW/tFgW6x/bCJG8FqQCEo3+Aro6EYUG4+cU+KJWu/X" crossorigin="anonymous">

        
        <script defer src="https://cdn.jsdelivr.net/npm/katex@0.12.0/dist/katex.min.js" integrity="sha384-g7c+Jr9ZivxKLnZTDUhnkOnsh30B4H0rpLUpJ4jAIKs4fnJI+sEnkvrMWph2EDg4" crossorigin="anonymous"></script>

        
        <script defer src="https://cdn.jsdelivr.net/npm/katex@0.12.0/dist/contrib/auto-render.min.js" integrity="sha384-mll67QQFJfxn0IYznZYonOWZ644AWYC+Pt2cHqMaRhXVrursRwvLnLaebdGIlYNa" crossorigin="anonymous"
                onload="renderMathInElement(document.body);"></script>

        <link href="https://fonts.googleapis.com/css?family=Nunito:400,300i,800&display=swap" rel="stylesheet" />
        <style>
                @font-face {
                        font-family: JuliaMono-Regular;
                        src: url("https://cdn.jsdelivr.net/gh/cormullion/juliamono/webfonts/JuliaMono-Regular.woff2");
                }
                body {
                        font-family: Nunito;
                        font-size: 13pt;
                        color: #1b2d45;
                }
                #content {
                        max-width: 40rem;
                        padding: 2rem;
                        margin: auto;
                }
                #sidebar {
                   position: absolute;
                        top: 0;
                        left: 0;
                        max-width: 16rem;
                        margin-left: 3rem;
                        margin-top: 3rem;
                }
                h1, h2, h3, h4, h5, h6 {
                        color: #00214d;
                }
                h1 {
                        font-size: 200%;
                }

                h2 {
                        font-size: 167%;
                }
                h3 {
                        font-size: 133%;
                        font-weight: normal;
                }
                pre {
                        background-color: #eee !important;
                        overflow-x: scroll;
                        font-family: JuliaMono-Regular, monospace;
                        font-size: 75%;
                        padding: 1rem;
                }
                code {
                        background-color: #eee !important;
                        font-family: JuliaMono-Regular, monospace;
                        font-size: 75%;
                }
                img {
                        max-width: 100%;
                        margin-top: 1rem;
                        margin-bottom: 1rem;
                }
                .katex { font-size: 1em !important;}
                .footer {
                        margin-top: 3rem;
                        font-size: 0.75rem;
                        color: #ccc;
                }
                .cc-symbol {
                        font-size: 1rem;
                }
                a, a:visited {
                         
                         
                        color: #ff5470;
                        padding: 1px;
                        border-radius: 2px;
                        text-decoration: none;
                }
                a.footnote-ref {
                    font-size: 0.9rem;
                }
                a.footnote-ref::before {
                    content: "[";
                }
                a.footnote-ref::after {
                    content: "]";
                }

                a:hover {
                        background-color: #ff5470;
                        color: #fff;
                }
                a[href^="https://"],
                a[href^="http://"] {
                        text-decoration: underline;
                }

                a[href^="https://"]:after,
                a[href^="http://"]:after {
                        content: "\2609";
                        text-decoration: none !important;
                }
        </style>
        <title>ruivieira.dev - Monotonic Cubic Spline interpolation (with some Rust)</title>
    <script type="application/javascript">
        var doNotTrack = false;
        if (!doNotTrack) {
            (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
                (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
                m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
            })(window,document,'script','https://www.google-analytics.com/analytics.js','ga');
            ga('create', 'UA-10507665-2', 'auto');

            ga('send', 'pageview');
        }
    </script>
</head>
<body>

<div id="sidebar">
        
            <h2>Contents</h2>
            <ul>
            
                <li><a href="#monotonic-cubic-splines">Monotonic Cubic Splines</a></li>
            
                <li><a href="#partial-application">Partial application</a></li>
            
            </ul>
        
        
                <h2>Backlinks</h2>

                <ul>
                        
                                <li><a href="index.html">index</a><sup>&#5833</sup></li>
                        
                    <li><a href="/content.html">content</a><sup>&#5833</sup></li>

                </ul>
        
    <div class="footer">
        modified 1608318378
    </div>

</div>

<div id="content">
    <h1 id="monotonic-cubic-spline-interpolation-with-some-rust">Monotonic Cubic Spline interpolation (with some Rust)</h1>
<p>Monotonic Cubic Spline interpolation (MCSI) is a popular and useful method which fits a smooth, continuous function through discrete data. MCSI has several applications in the field of computer vision and trajectory fitting. MCSI further guarantees monotonicity of the smoothed approximation, something which a cubic spline approximation alone cannot.<br />
In this post I'll show how to implement the method developed by F. N. Fritsch and R. E. Carlson <sup id="fnref:1"><a href="#fn:1" class="footnote-ref" role="doc-noteref">1</a></sup> in the <a href="https://www.rust-lang.org/">Rust</a> programming language.</p>
<h1 id="rust">Rust</h1>
<p><em>Why</em> Rust? Definitely this is a type of solution so simple that it can be implemented in  practically any programming language we can think of. However, I do find that the best way to get acquainted with a new language and its concepts is precisely to try to implement a simple and well-know solution. Although this post does not intend to be an introduction to the Rust language, some of the fundamentals will be presented as we go along.</p>
<p>Idiomatic Rust Object-Oriented Programming (OOP) has several characteristics which differ significantly from &quot;traditional&quot; OOP languages.<br />
Rust achieves data and behaviour encapsulation by means of defining data structure blueprints (called <code>struct</code>) and then defining their behaviour though a concrete implementation (through <code>impl</code>). As an example, a simple &quot;class&quot; <code>Foo</code> would consist of:</p>
<pre style="background-color:#fff"><span style="color:#000;font-weight:bold">struct</span> <span style="color:#458;font-weight:bold">Foo</span><span style="color:#bbb"> </span>{<span style="color:#bbb">
</span><span style="color:#bbb"></span>}<span style="color:#bbb">
</span><span style="color:#bbb">
</span><span style="color:#bbb"></span><span style="color:#000;font-weight:bold">impl</span><span style="color:#bbb"> </span>Foo<span style="color:#bbb"> </span>{<span style="color:#bbb">
</span><span style="color:#bbb">    </span><span style="color:#000;font-weight:bold">fn</span> <span style="color:#900;font-weight:bold">new</span>()<span style="color:#bbb"> </span>-&gt; <span style="color:#458;font-weight:bold">Foo</span><span style="color:#bbb"> </span>{<span style="color:#bbb">
</span><span style="color:#bbb">        </span><span style="color:#000;font-weight:bold">return</span><span style="color:#bbb"> </span>Foo<span style="color:#bbb"> </span>{};<span style="color:#bbb">
</span><span style="color:#bbb">  </span>}<span style="color:#bbb">
</span><span style="color:#bbb">  </span><span style="color:#000;font-weight:bold">fn</span> <span style="color:#900;font-weight:bold">method</span>(<span style="color:#000;font-weight:bold">&amp;</span><span style="color:#000;font-weight:bold">mut</span><span style="color:#bbb"> </span><span style="color:#999">self</span>)<span style="color:#bbb"> </span>{}<span style="color:#bbb">
</span><span style="color:#bbb">  </span><span style="color:#000;font-weight:bold">fn</span> <span style="color:#900;font-weight:bold">static_method</span>()<span style="color:#bbb"> </span>{}<span style="color:#bbb">
</span><span style="color:#bbb"></span>}<span style="color:#bbb">
</span><span style="color:#bbb">
</span><span style="color:#bbb"></span><span style="color:#000;font-weight:bold">pub</span><span style="color:#bbb"> </span><span style="color:#000;font-weight:bold">fn</span> <span style="color:#900;font-weight:bold">main</span>()<span style="color:#bbb"> </span>{<span style="color:#bbb">
</span><span style="color:#bbb">    </span><span style="color:#000;font-weight:bold">let</span><span style="color:#bbb"> </span><span style="color:#000;font-weight:bold">mut</span><span style="color:#bbb"> </span>f<span style="color:#bbb"> </span><span style="color:#000;font-weight:bold">=</span><span style="color:#bbb"> </span>Foo::new();<span style="color:#bbb">
</span><span style="color:#bbb">    </span>f.method();<span style="color:#bbb">
</span><span style="color:#bbb">    </span>Foo::static_method();<span style="color:#bbb">
</span><span style="color:#bbb"></span>}<span style="color:#bbb">
</span></pre><p>The &quot;constructor&quot; is defined typically as <code>new()</code>, but any &quot;static&quot; method which returns an initialised <code>struct</code> <em>can</em> be a constructor and &quot;object&quot; methods include the passing of the <code>self</code> instance not unlike languages such as Python. The <code>&amp;mut self</code> refers to the control or exclusive access to <code>self</code> and it is not directly related to <code>mut</code> mutability control. These concepts touch on Rust's borrowing and ownership model which, unfortunately, are <em>way</em> beyond the scope of this blog post. A nice introduction is provided by the &quot;<em>Rust programming book</em>&quot; available <a href="https://doc.rust-lang.org/book/ch04-00-understanding-ownership.html">here</a>.<br />
Our implementation aims at building a MCSI class <code>MonotonicCubicSpline</code> by splitting the algorithm into the slope calculation at <em>construction</em> time, a <em>Hermite interpolation</em> function and a <em>partial application function generator</em>. This will follow the general structure</p>
<pre style="background-color:#fff"><span style="color:#000;font-weight:bold">pub</span><span style="color:#bbb"> </span><span style="color:#000;font-weight:bold">struct</span> <span style="color:#458;font-weight:bold">MonotonicCubicSpline</span><span style="color:#bbb"> </span>{<span style="color:#bbb">
</span><span style="color:#bbb">    </span>m_x: <span style="color:#0086b3">Vec</span><span style="color:#000;font-weight:bold">&lt;</span><span style="color:#458;font-weight:bold">f64</span><span style="color:#000;font-weight:bold">&gt;</span>,<span style="color:#bbb">
</span><span style="color:#bbb">    </span>m_y: <span style="color:#0086b3">Vec</span><span style="color:#000;font-weight:bold">&lt;</span><span style="color:#458;font-weight:bold">f64</span><span style="color:#000;font-weight:bold">&gt;</span>,<span style="color:#bbb">
</span><span style="color:#bbb">    </span>m_m: <span style="color:#0086b3">Vec</span><span style="color:#000;font-weight:bold">&lt;</span><span style="color:#458;font-weight:bold">f64</span><span style="color:#000;font-weight:bold">&gt;</span><span style="color:#bbb">
</span><span style="color:#bbb"></span>}<span style="color:#bbb">
</span><span style="color:#bbb">
</span><span style="color:#bbb"></span><span style="color:#000;font-weight:bold">impl</span><span style="color:#bbb"> </span>MonotonicCubicSpline<span style="color:#bbb"> </span>{<span style="color:#bbb">
</span><span style="color:#bbb">	</span><span style="color:#000;font-weight:bold">pub</span><span style="color:#bbb"> </span><span style="color:#000;font-weight:bold">fn</span> <span style="color:#900;font-weight:bold">new</span>(x<span style="color:#bbb"> </span>: <span style="color:#000;font-weight:bold">&amp;</span><span style="color:#0086b3">Vec</span><span style="color:#000;font-weight:bold">&lt;</span><span style="color:#458;font-weight:bold">f64</span><span style="color:#000;font-weight:bold">&gt;</span>,<span style="color:#bbb"> </span>y<span style="color:#bbb"> </span>: <span style="color:#000;font-weight:bold">&amp;</span><span style="color:#0086b3">Vec</span><span style="color:#000;font-weight:bold">&lt;</span><span style="color:#458;font-weight:bold">f64</span><span style="color:#000;font-weight:bold">&gt;</span>)<span style="color:#bbb"> </span>-&gt; <span style="color:#458;font-weight:bold">MonotonicCubicSpline</span><span style="color:#bbb"> </span>{<span style="color:#bbb">
</span><span style="color:#bbb">		</span><span style="color:#998;font-style:italic">// ...
</span><span style="color:#998;font-style:italic"></span><span style="color:#bbb">	</span>}<span style="color:#bbb">
</span><span style="color:#bbb">	</span><span style="color:#000;font-weight:bold">pub</span><span style="color:#bbb"> </span><span style="color:#000;font-weight:bold">fn</span> <span style="color:#900;font-weight:bold">hermite</span>(point: <span style="color:#458;font-weight:bold">f64</span>,<span style="color:#bbb"> </span>x<span style="color:#bbb"> </span>: (<span style="color:#458;font-weight:bold">f64</span>,<span style="color:#bbb"> </span><span style="color:#458;font-weight:bold">f64</span>),<span style="color:#bbb"> </span>y: (<span style="color:#458;font-weight:bold">f64</span>,<span style="color:#bbb"> </span><span style="color:#458;font-weight:bold">f64</span>),<span style="color:#bbb"> </span>m: (<span style="color:#458;font-weight:bold">f64</span>,<span style="color:#bbb"> </span><span style="color:#458;font-weight:bold">f64</span>))<span style="color:#bbb"> </span>-&gt; <span style="color:#458;font-weight:bold">f64</span> {<span style="color:#bbb">
</span><span style="color:#bbb">		</span><span style="color:#998;font-style:italic">// ...
</span><span style="color:#998;font-style:italic"></span><span style="color:#bbb">	</span>}<span style="color:#bbb">
</span><span style="color:#bbb">
</span><span style="color:#bbb">	</span><span style="color:#000;font-weight:bold">pub</span><span style="color:#bbb"> </span><span style="color:#000;font-weight:bold">fn</span> <span style="color:#900;font-weight:bold">interpolate</span>(<span style="color:#000;font-weight:bold">&amp;</span><span style="color:#000;font-weight:bold">mut</span><span style="color:#bbb"> </span><span style="color:#999">self</span>,<span style="color:#bbb"> </span>point<span style="color:#bbb"> </span>: <span style="color:#458;font-weight:bold">f64</span>)<span style="color:#bbb"> </span>-&gt; <span style="color:#458;font-weight:bold">f64</span> {<span style="color:#bbb">
</span><span style="color:#bbb">		</span><span style="color:#998;font-style:italic">// ...
</span><span style="color:#998;font-style:italic"></span><span style="color:#bbb">	</span>}<span style="color:#bbb">
</span><span style="color:#bbb">
</span><span style="color:#bbb">	</span><span style="color:#000;font-weight:bold">fn</span> <span style="color:#900;font-weight:bold">partial</span>(x: <span style="color:#0086b3">Vec</span><span style="color:#000;font-weight:bold">&lt;</span><span style="color:#458;font-weight:bold">f64</span><span style="color:#000;font-weight:bold">&gt;</span>,<span style="color:#bbb"> </span>y: <span style="color:#0086b3">Vec</span><span style="color:#000;font-weight:bold">&lt;</span><span style="color:#458;font-weight:bold">f64</span><span style="color:#000;font-weight:bold">&gt;</span>)<span style="color:#bbb"> </span>-&gt; <span style="color:#458;font-weight:bold">impl</span><span style="color:#bbb"> </span><span style="color:#0086b3">Fn</span>(<span style="color:#458;font-weight:bold">f64</span>)<span style="color:#bbb"> </span>-&gt; <span style="color:#458;font-weight:bold">f64</span> {<span style="color:#bbb">
</span><span style="color:#bbb">		</span><span style="color:#998;font-style:italic">// ...
</span><span style="color:#998;font-style:italic"></span><span style="color:#bbb">	</span>}<span style="color:#bbb">
</span><span style="color:#bbb"></span>}<span style="color:#bbb">
</span></pre><p><code>Vec</code> is a vector, a typed growable collection available in Rust's standard library with documentation available <a href="https://doc.rust-lang.org/std/vec/struct.Vec.html">here</a>.</p>
<h2 id="monotonic-cubic-splines">Monotonic Cubic Splines</h2>
<p>MCSI hinges on the concept of cubic Hermite interpolators. The Hermite interpolation for the unit interval for a generic interval <span class="math inline">\((x_k,x_{k+1})\)</span> is</p>
<p><span class="math display">\[p(x)=p_k h_{00}(t)+ h_{10}(t)(x_{k+1}-x_k)m_k + \\ h_{01}(t)p_{k+1} + h_{11}(t)(x_{k+1}-x_{k})m_{k+1}.
\]</span></p>
<p>The <span class="math inline">\(h_{\star}\)</span> functions are usually called the <em>Hermite basis functions</em> in the literature and here we will use the factorised forms of:</p>
<p><span class="math display">\[\begin{aligned}
h_{00}(t) &= (1+2t)(1-t)^2 \\
h_{10}(t) &= t(1-t)^2 \\
h_{01}(t) &= t^2 (3-2t) \\
h_{11}(t) &= t^2 (t-1).
\end{aligned}
\]</span></p>
<p>This can be rewritten as</p>
<p><span class="math display">\[p(x) = (p_k(1 + 2t) + \Delta x_k m_k  t)(1-t)(1-t) + \\ (p_{k+1} (3 -2t) + \Delta x_k m_{k+1} (t-1))t^2
\]</span></p>
<p>where</p>
<p><span class="math display">\[\begin{aligned}
\Delta x_k &= x_{k+1} - x_k \\
t &= \frac{x-x_k}{h}.
\end{aligned}
\]</span></p>
<p>This associated Rust method is the above mentioned &quot;static&quot; <code>MonotonicCubicSpline::hermite()</code>:</p>
<pre style="background-color:#fff"><span style="color:#000;font-weight:bold">pub</span><span style="color:#bbb"> </span><span style="color:#000;font-weight:bold">fn</span> <span style="color:#900;font-weight:bold">hermite</span>(point: <span style="color:#458;font-weight:bold">f64</span>,<span style="color:#bbb"> </span>x<span style="color:#bbb"> </span>: (<span style="color:#458;font-weight:bold">f64</span>,<span style="color:#bbb"> </span><span style="color:#458;font-weight:bold">f64</span>),<span style="color:#bbb"> </span>y: (<span style="color:#458;font-weight:bold">f64</span>,<span style="color:#bbb"> </span><span style="color:#458;font-weight:bold">f64</span>),<span style="color:#bbb"> </span>m: (<span style="color:#458;font-weight:bold">f64</span>,<span style="color:#bbb"> </span><span style="color:#458;font-weight:bold">f64</span>))<span style="color:#bbb"> </span>-&gt; <span style="color:#458;font-weight:bold">f64</span> {<span style="color:#bbb">
</span><span style="color:#bbb">	</span><span style="color:#000;font-weight:bold">let</span><span style="color:#bbb"> </span>h<span style="color:#bbb"> </span><span style="color:#000;font-weight:bold">=</span><span style="color:#bbb"> </span>x.<span style="color:#099">1</span><span style="color:#bbb"> </span><span style="color:#000;font-weight:bold">-</span><span style="color:#bbb"> </span>x.<span style="color:#099">0</span>;<span style="color:#bbb">
</span><span style="color:#bbb">	</span><span style="color:#000;font-weight:bold">let</span><span style="color:#bbb"> </span>t<span style="color:#bbb"> </span><span style="color:#000;font-weight:bold">=</span><span style="color:#bbb"> </span>(point<span style="color:#bbb"> </span><span style="color:#000;font-weight:bold">-</span><span style="color:#bbb"> </span>x.<span style="color:#099">0</span>)<span style="color:#bbb"> </span><span style="color:#000;font-weight:bold">/</span><span style="color:#bbb"> </span>h;<span style="color:#bbb">
</span><span style="color:#bbb">	</span><span style="color:#000;font-weight:bold">return</span><span style="color:#bbb"> </span>(y.<span style="color:#099">0</span><span style="color:#bbb"> </span>(<span style="color:#099">1.0</span><span style="color:#bbb"> </span><span style="color:#000;font-weight:bold">+</span><span style="color:#bbb"> </span><span style="color:#099">2.0</span><span style="color:#bbb"> </span>t)<span style="color:#bbb"> </span><span style="color:#000;font-weight:bold">+</span><span style="color:#bbb"> </span>h<span style="color:#bbb"> </span>m.<span style="color:#099">0</span><span style="color:#bbb"> </span>t)<span style="color:#bbb"> </span>(<span style="color:#099">1.0</span><span style="color:#bbb"> </span><span style="color:#000;font-weight:bold">-</span><span style="color:#bbb"> </span>t)<span style="color:#bbb"> </span>(<span style="color:#099">1.0</span><span style="color:#bbb"> </span><span style="color:#000;font-weight:bold">-</span><span style="color:#bbb"> </span>t)<span style="color:#bbb">
</span><span style="color:#bbb">		</span><span style="color:#000;font-weight:bold">+</span><span style="color:#bbb"> </span>(y.<span style="color:#099">1</span><span style="color:#bbb"> </span>(<span style="color:#099">3.0</span><span style="color:#bbb"> </span><span style="color:#000;font-weight:bold">-</span><span style="color:#bbb"> </span><span style="color:#099">2.0</span><span style="color:#bbb"> </span>t)<span style="color:#bbb"> </span><span style="color:#000;font-weight:bold">+</span><span style="color:#bbb"> </span>h<span style="color:#bbb"> </span>m.<span style="color:#099">1</span><span style="color:#bbb"> </span>(t<span style="color:#bbb"> </span><span style="color:#000;font-weight:bold">-</span><span style="color:#bbb"> </span><span style="color:#099">1.0</span>))<span style="color:#bbb"> </span>t<span style="color:#bbb"> </span>t;<span style="color:#bbb">
</span><span style="color:#bbb"></span>}<span style="color:#bbb">
</span></pre><p>where the tuples correspond to <span class="math inline">\(x \to (x_k, x_{k+1})\)</span>, <span class="math inline">\(t \to (y_k, y_{k+1})\)</span> and <span class="math inline">\(m \to (m_k, m_{k+1})\)</span></p>
<p>For a series of data points <span class="math inline">\((x_k, y_k)\)</span> with <span class="math inline">\(k=1,\dots,n\)</span> we then calculate the slopes of the secant lines between consecutive points, that is:</p>
<p><span class="math display">\[\Delta_k = \frac{\Delta y_{k}}{\Delta x_k},\qquad \text{for}\ k=1,\dots,n-1
\]</span></p>
<p>with <span class="math inline">\(Delta y_k = y_{k+1}-y_k\)</span> and <span class="math inline">\(\Delta x_k\)</span> as defined previously.</p>
<p><img src="./images/splines/secants.gif" alt="" /></p>
<p>Since the data is represented by the vectors <code>x : Vec&lt;f64&gt;</code> and <code>y : Vec&lt;f64&gt;</code> we implement this in the &quot;constructor&quot;:</p>
<pre style="background-color:#fff"><span style="color:#000;font-weight:bold">let</span><span style="color:#bbb"> </span><span style="color:#000;font-weight:bold">mut</span><span style="color:#bbb"> </span>secants<span style="color:#bbb"> </span><span style="color:#000;font-weight:bold">=</span><span style="color:#bbb"> </span>vec<span style="color:#000;font-weight:bold">!</span>[<span style="color:#099">0.0</span><span style="color:#bbb"> </span>;<span style="color:#bbb"> </span>n<span style="color:#bbb"> </span><span style="color:#000;font-weight:bold">-</span><span style="color:#bbb"> </span><span style="color:#099">1</span>];<span style="color:#bbb">
</span><span style="color:#bbb"></span><span style="color:#000;font-weight:bold">let</span><span style="color:#bbb"> </span><span style="color:#000;font-weight:bold">mut</span><span style="color:#bbb"> </span>slopes<span style="color:#bbb">  </span><span style="color:#000;font-weight:bold">=</span><span style="color:#bbb"> </span>vec<span style="color:#000;font-weight:bold">!</span>[<span style="color:#099">0.0</span><span style="color:#bbb"> </span>;<span style="color:#bbb"> </span>n];<span style="color:#bbb">
</span><span style="color:#bbb"></span><span style="color:#000;font-weight:bold">for</span><span style="color:#bbb"> </span>i<span style="color:#bbb"> </span><span style="color:#000;font-weight:bold">in</span><span style="color:#bbb"> </span><span style="color:#099">0</span>..(n<span style="color:#000;font-weight:bold">-</span><span style="color:#099">1</span>)<span style="color:#bbb"> </span>{<span style="color:#bbb">
</span><span style="color:#bbb">	</span><span style="color:#000;font-weight:bold">let</span><span style="color:#bbb"> </span>dx<span style="color:#bbb"> </span><span style="color:#000;font-weight:bold">=</span><span style="color:#bbb"> </span>x[i<span style="color:#bbb"> </span><span style="color:#000;font-weight:bold">+</span><span style="color:#bbb"> </span><span style="color:#099">1</span>]<span style="color:#bbb"> </span><span style="color:#000;font-weight:bold">-</span><span style="color:#bbb"> </span>x[i];<span style="color:#bbb">
</span><span style="color:#bbb">	</span><span style="color:#000;font-weight:bold">let</span><span style="color:#bbb"> </span>dy<span style="color:#bbb"> </span><span style="color:#000;font-weight:bold">=</span><span style="color:#bbb"> </span>y[i<span style="color:#bbb"> </span><span style="color:#000;font-weight:bold">+</span><span style="color:#bbb"> </span><span style="color:#099">1</span>]<span style="color:#bbb"> </span><span style="color:#000;font-weight:bold">-</span><span style="color:#bbb"> </span>y[i];<span style="color:#bbb">
</span><span style="color:#bbb">	</span>secants[i]<span style="color:#bbb"> </span><span style="color:#000;font-weight:bold">=</span><span style="color:#bbb"> </span>dy<span style="color:#bbb"> </span><span style="color:#000;font-weight:bold">/</span><span style="color:#bbb"> </span>dx;<span style="color:#bbb">
</span><span style="color:#bbb"></span>}<span style="color:#bbb">
</span></pre><p>The next step is to average the secants in order to get the tangents, such that</p>
<p><span class="math display">\[m_k = \frac{\Delta_{k-1}+\Delta_k}{2},\qquad \text{for}\ k=2,\dots,n-1.
\]</span></p>
<p>This is achieved by the code:</p>
<pre style="background-color:#fff">slopes[<span style="color:#099">0</span>]<span style="color:#bbb"> </span><span style="color:#000;font-weight:bold">=</span><span style="color:#bbb"> </span>secants[<span style="color:#099">0</span>];<span style="color:#bbb">
</span><span style="color:#bbb"></span><span style="color:#000;font-weight:bold">for</span><span style="color:#bbb"> </span>i<span style="color:#bbb"> </span><span style="color:#000;font-weight:bold">in</span><span style="color:#bbb"> </span><span style="color:#099">1</span>..(n<span style="color:#000;font-weight:bold">-</span><span style="color:#099">1</span>)<span style="color:#bbb"> </span>{<span style="color:#bbb">
</span><span style="color:#bbb">    </span>slopes[i]<span style="color:#bbb"> </span><span style="color:#000;font-weight:bold">=</span><span style="color:#bbb"> </span>(secants[i<span style="color:#bbb"> </span><span style="color:#000;font-weight:bold">-</span><span style="color:#bbb"> </span><span style="color:#099">1</span>]<span style="color:#bbb"> </span><span style="color:#000;font-weight:bold">+</span><span style="color:#bbb"> </span>secants[i])<span style="color:#bbb"> </span><span style="color:#000;font-weight:bold">*</span><span style="color:#bbb"> </span><span style="color:#099">0.5</span>;<span style="color:#bbb">
</span><span style="color:#bbb"></span>}<span style="color:#bbb">
</span><span style="color:#bbb"></span>slopes[n<span style="color:#bbb"> </span><span style="color:#000;font-weight:bold">-</span><span style="color:#bbb"> </span><span style="color:#099">1</span>]<span style="color:#bbb"> </span><span style="color:#000;font-weight:bold">=</span><span style="color:#bbb"> </span>secants[n<span style="color:#bbb"> </span><span style="color:#000;font-weight:bold">-</span><span style="color:#bbb"> </span><span style="color:#099">2</span>];<span style="color:#bbb">
</span></pre><p>By definition, we want to ensure monotonicity of the interpolated points, but to guarantee this we must avoid the interpolation spline to go too far from a certain radius of the control points.<br />
If we define <span class="math inline">\(\alpha_k\)</span> and <span class="math inline">\(\beta_k\)</span> as</p>
<p><span class="math display">\[\begin{aligned}
\alpha_k &= \frac{m_k}{\Delta_k} \\
\beta_k &= \frac{m_{k+1}}{\Delta_k},
\end{aligned}
\]</span></p>
<p>to ensure the monotonicity of the interpolation we can impose the following constraint on the above quantities:</p>
<p><span class="math display">\[\phi(\alpha, \beta) = \alpha - \frac{(2\alpha+\beta-3)^2}{3(\alpha+\beta-2)}\geq 0,
\]</span></p>
<p>that is</p>
<p><span class="math display">\[\alpha + 2\beta - 3 \leq 0, \text{or}\ 2\alpha+\beta-3 \leq 0
\]</span></p>
<p>Typically the vector <span class="math inline">\((\alpha_k, \beta_k)\)</span> is restricted to a circle of radius 3, that is</p>
<p><span class="math display">\[\alpha^2_l + \beta_k^2>9,
\]</span></p>
<p>and then setting</p>
<p><span class="math display">\[m_{k+1} = t\beta_k\Delta_k,
\]</span></p>
<p>where</p>
<p><span class="math display">\[\begin{aligned}
h &amp;= \sqrt{\alpha^2_k + \beta^2_k} \\
t &amp;= \frac{3}{h}.
\end{aligned}
\]</span></p>
<p>One of the ways in which Rust implements polymorphism is through method dispatch. The <code>f64</code> primitive <a href="https://doc.rust-lang.org/std/primitive.f64.html#method.hypot">provides</a> a shorthand for the quantity <span class="math inline">\(\sqrt{\alpha^2_k + \beta^2_k}\)</span> as <span class="math inline">\(\alpha.\text{hypot}(\beta)\)</span>. The relevant Rust code will then be:</p>
<pre style="background-color:#fff"><span style="color:#000;font-weight:bold">for</span><span style="color:#bbb"> </span>i<span style="color:#bbb"> </span><span style="color:#000;font-weight:bold">in</span><span style="color:#bbb"> </span><span style="color:#099">0</span>..(n<span style="color:#000;font-weight:bold">-</span><span style="color:#099">1</span>)<span style="color:#bbb"> </span>{<span style="color:#bbb">
</span><span style="color:#bbb">    </span><span style="color:#000;font-weight:bold">if</span><span style="color:#bbb"> </span>secants[i]<span style="color:#bbb"> </span><span style="color:#000;font-weight:bold">==</span><span style="color:#bbb"> </span><span style="color:#099">0.0</span><span style="color:#bbb"> </span>{<span style="color:#bbb">
</span><span style="color:#bbb">        </span>slopes[i]<span style="color:#bbb"> </span><span style="color:#000;font-weight:bold">=</span><span style="color:#bbb"> </span><span style="color:#099">0.0</span>;<span style="color:#bbb">
</span><span style="color:#bbb">        </span>slopes[i<span style="color:#bbb"> </span><span style="color:#000;font-weight:bold">+</span><span style="color:#bbb"> </span><span style="color:#099">1</span>]<span style="color:#bbb"> </span><span style="color:#000;font-weight:bold">=</span><span style="color:#bbb"> </span><span style="color:#099">0.0</span>;<span style="color:#bbb">
</span><span style="color:#bbb">    </span>}<span style="color:#bbb"> </span><span style="color:#000;font-weight:bold">else</span><span style="color:#bbb"> </span>{<span style="color:#bbb">
</span><span style="color:#bbb">        </span><span style="color:#000;font-weight:bold">let</span><span style="color:#bbb"> </span>alpha<span style="color:#bbb"> </span><span style="color:#000;font-weight:bold">=</span><span style="color:#bbb"> </span>slopes[i]<span style="color:#bbb"> </span><span style="color:#000;font-weight:bold">/</span><span style="color:#bbb"> </span>secants[i];<span style="color:#bbb">
</span><span style="color:#bbb">        </span><span style="color:#000;font-weight:bold">let</span><span style="color:#bbb"> </span>beta<span style="color:#bbb"> </span><span style="color:#000;font-weight:bold">=</span><span style="color:#bbb"> </span>slopes[i<span style="color:#bbb"> </span><span style="color:#000;font-weight:bold">+</span><span style="color:#bbb"> </span><span style="color:#099">1</span>]<span style="color:#bbb"> </span><span style="color:#000;font-weight:bold">/</span><span style="color:#bbb"> </span>secants[i];<span style="color:#bbb">
</span><span style="color:#bbb">        </span><span style="color:#000;font-weight:bold">let</span><span style="color:#bbb"> </span>h<span style="color:#bbb"> </span><span style="color:#000;font-weight:bold">=</span><span style="color:#bbb"> </span>alpha.hypot(beta);<span style="color:#bbb">
</span><span style="color:#bbb">        </span><span style="color:#000;font-weight:bold">if</span><span style="color:#bbb"> </span>h<span style="color:#bbb"> </span><span style="color:#000;font-weight:bold">&gt;</span><span style="color:#bbb"> </span><span style="color:#099">3.0</span><span style="color:#bbb"> </span>{<span style="color:#bbb">
</span><span style="color:#bbb">            </span><span style="color:#000;font-weight:bold">let</span><span style="color:#bbb"> </span>t<span style="color:#bbb"> </span><span style="color:#000;font-weight:bold">=</span><span style="color:#bbb"> </span><span style="color:#099">3.0</span><span style="color:#bbb"> </span><span style="color:#000;font-weight:bold">/</span><span style="color:#bbb"> </span>h;<span style="color:#bbb">
</span><span style="color:#bbb">            </span>slopes[i]<span style="color:#bbb"> </span><span style="color:#000;font-weight:bold">=</span><span style="color:#bbb"> </span>t<span style="color:#bbb"> </span><span style="color:#000;font-weight:bold">*</span><span style="color:#bbb"> </span>alpha<span style="color:#bbb"> </span><span style="color:#000;font-weight:bold">*</span><span style="color:#bbb"> </span>secants[i];<span style="color:#bbb">
</span><span style="color:#bbb">            </span>slopes[i<span style="color:#bbb"> </span><span style="color:#000;font-weight:bold">+</span><span style="color:#bbb"> </span><span style="color:#099">1</span>]<span style="color:#bbb"> </span><span style="color:#000;font-weight:bold">=</span><span style="color:#bbb"> </span>t<span style="color:#bbb"> </span><span style="color:#000;font-weight:bold">*</span><span style="color:#bbb"> </span>beta<span style="color:#bbb"> </span><span style="color:#000;font-weight:bold">*</span><span style="color:#bbb"> </span>secants[i];<span style="color:#bbb">
</span><span style="color:#bbb">        </span>}<span style="color:#bbb">
</span><span style="color:#bbb">    </span>}<span style="color:#bbb">
</span><span style="color:#bbb"></span>}<span style="color:#bbb">
</span></pre><p>We are now able to define a &quot;smooth function&quot; generator using MCSI. We generate a smooth function <span class="math inline">\(g(\cdot)\)</span> given a set of <span class="math inline">\((x_k, y_k)\)</span> points, such that</p>
<p><span class="math display">\[f(x_k, y_k, p) \to g(p).
\]</span></p>
<h2 id="partial-application">Partial application</h2>
<p>Before anything, it is important to recall the difference between partial application and <em>currying</em>, since the two are (incorrectly) used interchangeably quite often.<br />
<em>Function currying</em> allows to factor functions with multiple arguments into a chain of single-argument functions, that is</p>
<p><span class="math display">\[f(x, y, z) = h(x)(y)(z)
\]</span></p>
<p>The concept is prevalent in functional programming, since its initial formalisation <sup id="fnref:2"><a href="#fn:2" class="footnote-ref" role="doc-noteref">2</a></sup>. Partial application, however, generally aims at using an existing function conditioned on some argument as a basis to build functions with a reduced arity. In this case this would be useful since ultimately we want to create a smooth, continuous function based on the control points <span class="math inline">\((x_k, y_k)\)</span>. The partial application implementation is done in Rust as</p>
<pre style="background-color:#fff"><span style="color:#000;font-weight:bold">pub</span><span style="color:#bbb"> </span><span style="color:#000;font-weight:bold">fn</span> <span style="color:#900;font-weight:bold">partial</span>(x: <span style="color:#0086b3">Vec</span><span style="color:#000;font-weight:bold">&lt;</span><span style="color:#458;font-weight:bold">f64</span><span style="color:#000;font-weight:bold">&gt;</span>,<span style="color:#bbb"> </span>y: <span style="color:#0086b3">Vec</span><span style="color:#000;font-weight:bold">&lt;</span><span style="color:#458;font-weight:bold">f64</span><span style="color:#000;font-weight:bold">&gt;</span>)<span style="color:#bbb"> </span>-&gt; <span style="color:#458;font-weight:bold">impl</span><span style="color:#bbb"> </span><span style="color:#0086b3">Fn</span>(<span style="color:#458;font-weight:bold">f64</span>)<span style="color:#bbb"> </span>-&gt; <span style="color:#458;font-weight:bold">f64</span> {<span style="color:#bbb">
</span><span style="color:#bbb">    </span><span style="color:#000;font-weight:bold">move</span><span style="color:#bbb"> </span><span style="color:#000;font-weight:bold">|</span>p<span style="color:#000;font-weight:bold">|</span><span style="color:#bbb"> </span>{<span style="color:#bbb">
</span><span style="color:#bbb">        </span><span style="color:#000;font-weight:bold">let</span><span style="color:#bbb"> </span><span style="color:#000;font-weight:bold">mut</span><span style="color:#bbb"> </span>spline<span style="color:#bbb"> </span><span style="color:#000;font-weight:bold">=</span><span style="color:#bbb"> </span>MonotonicCubicSpline::new(<span style="color:#000;font-weight:bold">&amp;</span>x,<span style="color:#bbb"> </span><span style="color:#000;font-weight:bold">&amp;</span>y);<span style="color:#bbb">
</span><span style="color:#bbb">        </span>spline.interpolate(p)<span style="color:#bbb">
</span><span style="color:#bbb">    </span>}<span style="color:#bbb">
</span><span style="color:#bbb"></span>}<span style="color:#bbb">
</span></pre><p>An example of how to generate a concrete smoothed continuous function from a set of control points can be:</p>
<pre style="background-color:#fff"><span style="color:#000;font-weight:bold">let</span><span style="color:#bbb"> </span>x<span style="color:#bbb"> </span><span style="color:#000;font-weight:bold">=</span><span style="color:#bbb"> </span>vec<span style="color:#000;font-weight:bold">!</span>[<span style="color:#099">0.0</span>,<span style="color:#bbb"> </span><span style="color:#099">2.0</span>,<span style="color:#bbb"> </span><span style="color:#099">3.0</span>,<span style="color:#bbb"> </span><span style="color:#099">10.0</span>];<span style="color:#bbb">
</span><span style="color:#bbb"></span><span style="color:#000;font-weight:bold">let</span><span style="color:#bbb"> </span>y<span style="color:#bbb"> </span><span style="color:#000;font-weight:bold">=</span><span style="color:#bbb"> </span>vec<span style="color:#000;font-weight:bold">!</span>[<span style="color:#099">1.0</span>,<span style="color:#bbb"> </span><span style="color:#099">4.0</span>,<span style="color:#bbb"> </span><span style="color:#099">8.0</span>,<span style="color:#bbb"> </span><span style="color:#099">10.5</span>];<span style="color:#bbb">
</span><span style="color:#bbb"></span><span style="color:#000;font-weight:bold">let</span><span style="color:#bbb"> </span>g<span style="color:#bbb"> </span><span style="color:#000;font-weight:bold">=</span><span style="color:#bbb"> </span>partial(x,<span style="color:#bbb"> </span>y);<span style="color:#bbb">
</span><span style="color:#bbb">
</span><span style="color:#bbb"></span><span style="color:#998;font-style:italic">// calculate an interpolated point
</span><span style="color:#998;font-style:italic"></span><span style="color:#000;font-weight:bold">let</span><span style="color:#bbb"> </span>point<span style="color:#bbb"> </span><span style="color:#000;font-weight:bold">=</span><span style="color:#bbb"> </span>g(<span style="color:#099">0.39</span>);<span style="color:#bbb">
</span></pre><p><img src="./images/splines/interpolation.png" alt="" /></p>
<p>The full code can be found <a href="https://gitlab.com/ruivieira/mentat/blob/master/src/lib.rs">here</a>.</p>
<div class="footnotes" role="doc-endnotes">
<hr />
<ol>
<li id="fn:1" role="doc-endnote">
<p>Fritsch, F. N., &amp; Carlson, R. E. (2005). Monotone Piecewise Cubic Interpolation. <em>SIAM Journal on Numerical Analysis</em>. https://doi.org/10.1137/0717021 <a href="#fnref:1" class="footnote-backref" role="doc-backlink">&#x21a9;&#xfe0e;</a></p>
</li>
<li id="fn:2" role="doc-endnote">
<p>Curry, Haskell; Feys, Robert (1958). Combinatory logic. I (2 ed.). Amsterdam, Netherlands: North-Holland Publishing Company. <a href="#fnref:2" class="footnote-backref" role="doc-backlink">&#x21a9;&#xfe0e;</a></p>
</li>
</ol>
</div>

    <div class="footer">
        <span class="cc-symbol">&#127341;</span> 2020 CC BY Rui Vieira
    </div>
</div>

</body>
</html>