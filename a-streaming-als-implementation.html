<!DOCTYPE html>
<head>
        <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.12.0/dist/katex.min.css" integrity="sha384-AfEj0r4/OFrOo5t7NnNe46zW/tFgW6x/bCJG8FqQCEo3+Aro6EYUG4+cU+KJWu/X" crossorigin="anonymous">

        
        <script defer src="https://cdn.jsdelivr.net/npm/katex@0.12.0/dist/katex.min.js" integrity="sha384-g7c+Jr9ZivxKLnZTDUhnkOnsh30B4H0rpLUpJ4jAIKs4fnJI+sEnkvrMWph2EDg4" crossorigin="anonymous"></script>

        
        <script defer src="https://cdn.jsdelivr.net/npm/katex@0.12.0/dist/contrib/auto-render.min.js" integrity="sha384-mll67QQFJfxn0IYznZYonOWZ644AWYC+Pt2cHqMaRhXVrursRwvLnLaebdGIlYNa" crossorigin="anonymous"
                onload="renderMathInElement(document.body);"></script>
        <style>
                @font-face {
                        font-family: JuliaMono-Regular;
                        src: url("https://cdn.jsdelivr.net/gh/cormullion/juliamono/webfonts/JuliaMono-Regular.woff2");
                }
                body {
                        font-size: 1.2rem;
                        color: #1b2d45;
                }
                #content {
                        max-width: 38rem;
                        padding: 2rem;
                        margin: auto;
                }
                #sidebar {
                   position: absolute;
                        top: 0;
                        left: 0;
                        max-width: 13rem;
                        margin-left: 3rem;
                        margin-top: 3rem;
                }
                h1, h2, h3, h4, h5, h6 {
                        color: #00214d;
                }
                pre {
                        background-color: #eee !important;
                        overflow-x: scroll;
                        font-family: JuliaMono-Regular, monospace;
                        font-size: 1rem;
                        padding: 1rem;
                }
                code {
                        background-color: #eee !important;
                        font-family: JuliaMono-Regular, monospace;
                        font-size: 1rem;
                }
                img {
                        max-width: 38rem;
                }
                .katex { font-size: 1em !important;}
                .footer {
                        margin-top: 3rem;
                        font-size: 0.75rem;
                        color: #ccc;
                }
                .cc-symbol {
                        font-size: 1rem;
                }
                a, a:visited {
                         
                         
                        color: #ff5470;
                        padding: 1px;
                        border-radius: 2px;
                }
                a.footnote-ref {
                    font-size: 0.9rem;
                }
                a.footnote-ref::before {
                    content: "[";
                }
                a.footnote-ref::after {
                    content: "]";
                }

                a:hover {
                        background-color: #ff5470;
                        color: #fff;
                }
                a[href^="https://"],
                a[href^="http://"] {
                        text-decoration: underline;
                }

                a[href^="https://"]:after,
                a[href^="http://"]:after {
                        content: "\2609";
                        text-decoration: none !important;
                }
        </style>
        <title>ruivieira.dev - A streaming ALS implementation</title>
    <script type="application/javascript">
        var doNotTrack = false;
        if (!doNotTrack) {
            (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
                (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
                m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
            })(window,document,'script','https://www.google-analytics.com/analytics.js','ga');
            ga('create', 'UA-10507665-2', 'auto');

            ga('send', 'pageview');
        }
    </script>
</head>
<body>

<div id="sidebar">
        
            <h2>Contents</h2>
            <ul>
            
                <li><a href="#recommendation-engines">Recommendation engines</a></li>
            
                <li><a href="#collaborative-filtering">Collaborative filtering</a></li>
            
                <li><a href="#alternating-least-squares-als--">Alternating Least Squares (ALS)  </a></li>
            
            </ul>
        
        
                <h2>Backlinks</h2>

                <ul>
                        
                                <li><a href="index.html">index</a><sup>&#5833</sup></li>
                        

                </ul>
        
    <div class="footer">
        modified 1608318016
    </div>

</div>

<div id="content">
    <h1 id="a-streaming-als-implementation">A streaming ALS implementation</h1>
<p>In this blog post I would like to talk a little bit about recommendation engines in general and how to build a streaming recommendation engine on top of <a href="https://spark.apache.org/">Apache Spark</a>.</p>
<p>I will start by introducing the concept of <a href="#collab">collaborative filtering</a>, and focus in two variants: <a href="#batch_als">batch</a> and <a href="#streaming_als">streaming</a> Alternating Least Squares (ALS). I will look at the principles of a streaming distributed recommendation engine on Spark and finally, I'll talk about practical issues when using these methods.</p>
<h2 id="recommendation-engines">Recommendation engines</h2>
<p>So what <em>are</em> &quot;recommendation engines&quot;?</p>
<p>Recommendation engines are a popular method to match <em>users</em>, <em>products</em> and historical <em>data</em> on user behaviour.</p>
<h2 id="collaborative-filtering">Collaborative filtering</h2>
<p>In the majority of cases, we assume there's a unique mapping between a <em>user</em> <span class="math inline">\(x\)</span>, a <em>product</em> <span class="math inline">\(y\)</span> and <em>rating</em> <span class="math inline">\(\mathsf{R}_{x,y}\)</span>.</p>
<p><span class="math display">\[\left(x,y\right) \mapsto \mathsf{R}_{x,y}
\]</span></p>
<p>The &quot;collaborative&quot; aspect refers to the fact that we are using collective information from a group of users and &quot;filtering&quot; is simply a synonym for &quot;prediction&quot;.</p>
<p>So, we use collaborative filtering quite frequently in our daily life and it really seems like common sense.</p>
<p>The main principle is that if a group of people tend to collectively have similar tastes, it is more likely that they agree on an unknown product.</p>
<p>Let's imagine that you have a number of friends with whom you share a very similar musical taste, let's call it <code>A</code> and another group, <code>B</code>, compared to which you have very different musical tastes.</p>
<p>If group <code>A</code> and group <code>B</code> both recommend you a new album which they regard highly, which one would you pick?</p>
<p>You will probably pick the album from group <code>A</code>, right? So that's collaborative filtering in a nutshell.</p>
<p><img src="./images/als/groups.png" alt="Data" /></p>
<p><em>Bonus question</em>: what if an album is considered really bad by group <code>B</code>? Does it mean you'll like it?</p>
<p>It's difficult to tell. Because group <code>A</code> has relevance to you, it's easy to match.</p>
<p>Because <code>B</code> is too dissimilar, a low rating is not very informative.</p>
<h2 id="alternating-least-squares-als">Alternating Least Squares (ALS)</h2>
<p>One of the most popular collaborative filtering methods is <a href="https://link.springer.com/chapter/10.1007/978-3-540-68880-8_32">Alternating Least Squares</a> (ALS).</p>
<p>In ALS we assume that the available rating data can be represented in a sparse matrix form, that is, we will assume a sequential ordering of both users and products. Each entry of the matrix will then represent the rating for a unique pair of user and products.</p>
<p>If we then consider ratings data as a matrix, let's call it <span class="math inline">\(\mathsf{R}\)</span>, the <em>user</em> and <em>product</em> ids will represent coordinates in a ratings matrix and the actual rating will be the value for that particular entry. To keep the notation consistent with the above we simply call the entry <span class="math inline">\((x,y)\)</span> as <span class="math inline">\(\mathsf{R}_{x,y}\)</span>. This will look something like the matrix represented in the figure below.</p>
<p><img src="./images/als/ratings_table.png" alt="Ratings table" /></p>
<p>The idea behind ALS is to factorise the ratings matrix <span class="math inline">\(\mathsf{R}_{x,y}\)</span> into two matrices <span class="math inline">\(\mathsf{U}\)</span> and <span class="math inline">\(\mathsf{P}\)</span>, which in turn, when multiplied back, will return an approximation of the original ratings matrix, that is:</p>
<p><span class="math display">\[\mathsf{R} \approx \hat{\mathsf{R}} = \mathsf{U}^T \mathsf{P}
\]</span></p>
<p>To &quot;predict&quot; a missing rating for a user <span class="math inline">\(x\)</span> and product <span class="math inline">\(y\)</span>, we can simply multiply two vectors, namely the <span class="math inline">\(x\)</span> row from the user latent factors and the <span class="math inline">\(y\)</span> column from the product latent factors, <span class="math inline">\(\hat{\mathsf{R}}_{x,y}\)</span>, that is:</p>
<p><span class="math display">\[\hat{\mathsf{R}}_{x,y} = \mathsf{U}_x^T \mathsf{P}_y
\]</span></p>
<p>There are several ways to tackle this factorisation problem and we will cover two of them in here. We will first look at a <a href="#batch_als">batch method</a>, which aims at factorising using the whole of the ratings matrix and a <a href="#streaming_als">stochastic gradient descent method</a>, which uses a single observation at a time.</p>
<h3 id="batch-als">Batch ALS</h3>
<p>This factorisation is performed by first defining an (objective) loss function (here called <span class="math inline">\(\ell\)</span>).</p>
<p>A general form is represented below where, as before, <span class="math inline">\(\mathsf{R}_{x,y}\)</span> is the <em>true rating</em> and <span class="math inline">\(\hat{\mathsf{R}}_{x,y}\)</span> is the <em>predicted rating</em>, calculated as seen previously. The remaining terms are simply regularisation terms to help prevent overfitting.</p>
<p><span class="math display">\[\ell = \sum c_{x,y} \left(\mathsf{R}_{x,y} - \underbrace{\mathsf{U}_x^T \mathsf{P}_y}_{\hat{\mathsf{R}}_{x,t}}\right)^2 + \lambda\left(\left\lVert \mathsf{U} \right\rVert^2 + \left\lVert \mathsf{P} \right\rVert^2\right)
\]</span></p>
<p>The value of <span class="math inline">\((c_{x,y})\)</span> constitutes a penalisation function and will depend on whether we are considering <em>explicit</em> or <em>implicit</em> feedback. If we consider the known ratings as our training dataset <span class="math inline">\(\mathcal{T}\)</span>, then, in the case of explicit feedback we have</p>
<p><span class="math display">\[c_{x,y} = \begin{cases}
0,\qquad\text{if}\ \left(x,y\right) \notin \mathcal{T} \\\\
1,\qquad\text{if}\ \left(x,y\right) \in \mathcal{T}
\end{cases}
\]</span></p>
<p>Constraining our loss function to only include known ratings. The implicit feedback case is different (and a possible future topic) and for the remainder of this post we will only consider the explicit feedback case. Given the above, we can then simplify our loss function, in the explicit feedback case, to</p>
<p><span class="math display">\[\ell = \sum_{x,y \in \mathcal{T}} \left(\mathsf{R}_{x,y} -\hat{\mathsf{R}}_{x,y}\right)^2 + \lambda\left(\left\lVert \mathsf{U} \right\rVert^2 + \left\lVert \mathsf{P} \right\rVert^2\right)
\]</span></p>
<p>Minimizing <span class="math inline">\(\ell\)</span> is however an NP-hard problem, due to its non-convexity. However, if we treat <span class="math inline">\(\mathsf{U}\)</span> as constant, then <span class="math inline">\(\ell\)</span> is a convex in relation to <span class="math inline">\(\mathsf{P}\)</span> and if we treat <span class="math inline">\(\mathsf{P}\)</span> as constant, <span class="math inline">\(\ell\)</span> is convex in relation to <span class="math inline">\(\mathsf{U}\)</span>. We can then alternate between fixing <span class="math inline">\(\mathsf{U}\)</span> and <span class="math inline">\(\mathsf{P}\)</span>, changing the values such that the loss function <span class="math inline">\(\ell\)</span> (above) is minimized. This procedure is then repeated until we reach convergence.</p>
<p>The way that ALS works is, in simplified terms, to find the factors <span class="math inline">\(\mathsf{U}\)</span> and <span class="math inline">\(\mathsf{P}\)</span>, which when multiplied together provide an approximation of our ratings matrix <span class="math inline">\(\mathsf{R}\)</span>, as we've seen previously.</p>
<p><img src="./images/als/rupt.png" alt="" /></p>
<p>Once we have the factors <span class="math inline">\(\mathsf{U}\)</span> and <span class="math inline">\(\mathsf{P}\)</span>, we can then predict the missing values in <span class="math inline">\(\mathsf{R}\)</span> by using the approximation <span class="math inline">\(\hat{\mathsf{R}}\)</span>.</p>
<p>It is clear that in a real world scenario we would have <em>many</em> missing ratings, simply due to the assumption that no user rates all products (if they did, the case for a recommendation engine will be significantly weaker). ALS is designed to deal with sparse matrices and to fill the blanks using <em>predicted values</em>. After factorization, our approximated ratings matrix will look something like this:</p>
<p><img src="./images/als/ratings%5Ctable%5Cfilled.png" alt="" /></p>
<p>As mentioned previously, the first step is then to minimise the loss function. In this case we take the partial derivatives and set them to zero and fortunately this has a closed form solution. We get a system of linear equations which we can easily implement. The system will correspond to the solution of</p>
<p><span class="math display">\[\frac{\partial \ell}{\partial \mathsf{U}_x}=0, \qquad \frac{\partial \ell}{\partial \mathsf{P}_y}=0.
\]</span></p>
<p>We start by solving the user latent factor minimisation using:</p>
<p><span class="math display">\[\frac{1}{2}\frac{\partial \ell}{\partial \mathsf{U}_x}=0 \\\\

\frac{1}{2}\frac{\partial}{\partial \mathsf{U}_x} \sum_{x,y \in \mathcal{T}} \left(\mathsf{R}_{x,y} - \mathsf{U}_x^T \mathsf{P}_y\right)^2 + \lambda\left(\left\lVert \mathsf{U} \right\rVert^2 + \left\lVert \mathsf{P} \right\rVert^2\right)=0 \\\\

-\sum_{x,y \in \mathcal{T}} \left(\mathsf{R}_{x,y} - \mathsf{U}_x^T \mathsf{P}_y\right)\mathsf{P}_y^T + \lambda \mathsf{U}\_x^T=0\\\\

-\left(\mathsf{R}_x -\mathsf{U}_x^T \mathsf{P}^T\right)\mathsf{P} + \lambda \mathsf{U}_x^T=0\\\\

\mathsf{U}_x^T\left(\mathsf{P}^T \mathsf{P} + \lambda \boldsymbol{\mathsf{I}}\right) = \mathsf{R}_x \mathsf{P} \\\\

\mathsf{U}_x^T = \mathsf{R}_x \mathsf{P} \left(\mathsf{P}^T \mathsf{P} + \lambda \boldsymbol{\mathsf{I}}\right)^{-1}.
\]</span></p>
<p>Similarly, we can solve for the product latent factor by using:</p>
<p><span class="math display">\[\frac{1}{2}\frac{\partial \ell}{\partial \mathsf{P}_y}=0 \\\\

-\sum_{x,y \in \mathcal{T}} \left(\mathsf{R}\_{x,y} - \mathsf{P}\_y^T \mathsf{U}_x\right)\mathsf{U}_x^T + \lambda \mathsf{P}_y^T=0\\\\

-\left(\mathsf{R}_y - \mathsf{P}_y^T \mathsf{U}^T\right)\mathsf{U} + \lambda \mathsf{P}_y^T=0\\\\

\mathsf{P}_y^T\left(\mathsf{U}^T \mathsf{U} + \lambda \boldsymbol{\mathsf{I}}\right) = \mathsf{R}_y \mathsf{U} \\\\

\mathsf{P}_y^T = \mathsf{R}_y \mathsf{U} \left(\mathsf{U}^T \mathsf{U} + \lambda \boldsymbol{\mathsf{I}}\right)^{-1}.
\]</span></p>
<p>We can then calculate each factor iteratively, by fixing the other one and solving the estimator. While this process is alternated, an error measure (usually the <em>Root Mean Squared Error</em> <a href="error-metrics.html#root-mean-squared-error">RMSE</a>), or <span class="math inline">\(RMSE\)</span> is calculated (as below) between the rating matrix approximation given by the latent factors and the ratings which we have, <span class="math inline">\(\mathcal{T}\)</span>. This method is guaranteed to converge and when we consider out approximation to be good enough, or after a set number of iterations we can then stop the refinement.</p>
<p><span class="math display">\[RMSE = \sqrt{\frac{1}{n}\sum_{x,y \in \mathcal{T}}\lvert \hat{\mathsf{R}}_{x,y} - \mathsf{R}_{x,y}\rvert}
\]</span></p>
<p>After the latent factors are estimated, we can then use them to try to recreate the original ratings matrix</p>
<p>with the approximation as we've seen. The missing ratings in the original matrix will now be filled by values which minimize the least squares recursion and these are taken as the ratings &quot;predictions&quot;.</p>
<p>To illustrate the working of ALS, let's assume we have a very quirky shop that only ever sells 300 products and has exactly 300 customers. On top of that, users are allowed to use 8 bit to rate the products. We will also assume in this unusual shop that every user has rated every product.</p>
<p>Now we're humans, and we visualise patterns in colour more easily than in numbers. We will assign a palette to the ratings, so that each rating corresponds to a colour.</p>
<p><img src="./images/als/colour%5Cmatrix.png" alt="" /></p>
<p>I think you know where this is going ... we make up this final ratings matrix so now we can visualise the ALS progress.</p>
<p><img src="./images/als/mona_lisa_pixelated_viridis.png" alt="" /></p>
<p>So how do we perform this factorisation? The initial step is to fill the latent factors <span class="math inline">\(\mathsf{U}\)</span> and <span class="math inline">\(\mathsf{P}\)</span>) with random values. Since at this point, we assume we don't have any ratings, having random factors will lead to an initial random guess of the ratings matrix.</p>
<p><img src="./images/als/initial.png" alt="" /></p>
<p>We then proceed to calculate each factor matrix, as we've seen, by calculating one using the estimator while keeping the other one constant and then alternating. We can see by the movie below that at each iteration the approximation to the original ratings gets better, stabilising after a few steps.</p>
<p>This is to be expected, in this case, since this would be the simplest implementation of ALS: a batch ALS on a single machine where we know all the ratings.</p>
<p><video width="100%" controls loop autoplay><source src='./images/als/simple_factorization.mp4' type='video/mp4'></video></p>
<p>So a fair question that arises is: why can't we update this model and perform recommendations in a streaming fashion using this method?</p>
<p>After all, if users add product ratings, we can simply update the predictions by recalculating the factors!</p>
<p>The problem is that when a new rating is added, or when new users and new products are added, we need to recalculate the entirety of the <span class="math inline">\(\mathsf{U}\)</span> and <span class="math inline">\(\mathsf{P}\)</span> matrices, and to do so, we need to have access to all of the data, <span class="math inline">\(\mathsf{R}\)</span>.</p>
<h3 id="streaming-als">Streaming ALS</h3>
<p>Ideally, we want a method that would allow us to update <span class="math inline">\(\mathsf{U}\)</span> and <span class="math inline">\(\mathsf{P}\)</span> using one observation, <span class="math inline">\(\mathsf{R}_{x,y}\)</span> at a time</p>
<p>It turns out that the <em>Stochastic Gradient Descent</em> (or SGD) method allows us to do precisely that. We'll look at the specific variant of SGD we've used which is called <em>Bias-Stochastic Gradient Descent</em> (B-SGD).</p>
<p>It is important to keep in mind, under a certain point of view, both methods aim at the same thing.</p>
<p><img src="./images/als/batch_streaming_comparison.png" alt="" /></p>
<p>They both try to factorise the ratings matrix as latent factors, which would then be used to perform predictions. The main differences are of course, how the data is used (batch or one observation at the time) and how the factorisation is calculated.</p>
<p>In the SGD case we use the concept of biases in both users and items. The bias is a measure of how consistently a product is rated by different users. The bias of rating <span class="math inline">\((x,y)\)</span>, that is the rating given by user <span class="math inline">\(x\)</span> to product <span class="math inline">\(y\)</span>, can be calculated as the sum of <span class="math inline">\(\mu\)</span>, an overall average rating and the observed deviations of user <span class="math inline">\(x\)</span>, which we call <span class="math inline">\(b_x\)</span>, and the observed deviations of product <span class="math inline">\(y\)</span>, called <span class="math inline">\(b_y\)</span>, that is:</p>
<p><span class="math display">\[b_{x,y} = \mu + b_x + b_y
\]</span></p>
<p>This bias information is now incorporated in the rating prediction. We can see that the SGD prediction is simply the batch prediction plus the corresponding bias term</p>
<p><span class="math display">\[\hat{\mathsf{R}}_{x,y} = b_{x,y} + \underbrace{\mathsf{U}^T_x \cdot \mathsf{P}_y}_{batch}
\]</span></p>
<p>If we take the loss function definition for the batch method (and still considering the explicit feedback case), we can then replace the predicted rating formulation with our new one. We have, as before, some regularisation terms, but now also include a new regularisation term for the bias components,</p>
<p>but we don't need to go into that.</p>
<p><span class="math display">\[\ell_{SGD} = \sum_{x,y \in \mathcal{T}} \left(\mathsf{R}_{x,y} - b_{x,y} - \hat{\mathsf{R}}_{x,y}\right)^2 + \lambda\left(\left\lVert \mathsf{U} \right\rVert^2 + \left\lVert \mathsf{P} \right\rVert^2 + b_x^2 + b_y^2\right)
\]</span></p>
<p>Since calculating the full gradient is computationally very expensive, we calculate it for a single observation. As we can see, the SGD method allows us to update the user and product specific bias as well as a single user and product latent factor row given a single rating.</p>
<p>Provided we have a single rating, the rating of user <span class="math inline">\(x\)</span> for product <span class="math inline">\(y\)</span>, we can update the biases as well as the latent vectors for user <span class="math inline">\(x\)</span> and for product <span class="math inline">\(y\)</span>, that is, we no longer need to update the entire matrices <span class="math inline">\(\mathsf{U}\)</span> and <span class="math inline">\(\mathsf{P}\)</span>, while still maintaining a convergence property.</p>
<p>Provided with a learning rate <span class="math inline">\(\gamma\)</span> and defining our <em>prediction error</em> as</p>
<p><span class="math display">\[\epsilon_{x,y}=\mathsf{R}_{x,y}-\hat{\mathsf{R}}_{x,y},
\]</span></p>
<p>the biases and latent factors can now be updated in the opposite direction of the calculated gradient, proportionally to the learning rate, such that</p>
<p><span class="math display">\[\begin{aligned}

b_x &\leftarrow b_x + \gamma \left(\epsilon_{x,y}-\lambda_x b_x\right) \\\\

b_y &\leftarrow b_y + \gamma \left(\epsilon_{x,y}-\lambda_y b_y\right) \\\\


\mathsf{U}_x &\leftarrow \mathsf{U}_x + \gamma \left(\epsilon_{x,y}\mathsf{P}_y - \lambda^\prime_x \mathsf{U}_x\right) \\\\

\mathsf{P}_y &\leftarrow \mathsf{P}_y + \gamma \left(\epsilon_{x,y}\mathsf{U}_x - \lambda^\prime_y \mathsf{P}_y\right)

\end{aligned}
\]</span></p>
<p>So the practical difference, in terms of streaming data is evident now. Given that, in both methods, the objective is to estimate the latent factors, given the ratings: with batch ALS, whenever we get a new rating, we need to fully recalculate the factors iteratively until we reach convergence. Conversely, with an SGD based factorisation, whenever we have a new rating, we can simply estimate the relevant row and column in the latent factors, by calculating the gradients and adjusting its values.</p>
<p><img src="./images/als/batch%5Cstreaming%5Ccomparison%5C2.png" alt="" /></p>
<p>Next we show the previous manufactured ratings matrix being factorised using B-SGD. We now simply recalculate the biases and a single latent factor vector, one observation at the time. We can see that, as expected, the convergence is slower (we <em>are</em> using a single observation at each step) but in the end, it produces a similar result.</p>
<p><video width="100%" controls loop autoplay><source src='./images/als/sgd_factorization.mp4' type='video/mp4'></video></p>
<p>Now, this works fine for a single machine implementing streaming ALS. But we are interested in scaling this to something larger than this example so we will use a distributed implementation of ALS. And this is were it can start to get tricky. As it is the case with distributed algorithms, there are some pitfalls which we need to avoid in order to have a performant implementation. We will look at a few of these by looking at the Apache Spark's and its default ALS implementation.</p>
<h3 id="apache-spark">Apache Spark</h3>
<p>As probably most of you are familiar with, Spark is an Apache community project which aims at providing a modern platform for distributed computations. Spark provides several core data structures, such as <code>RDD</code>s (<a href="https://spark.apache.org/docs/latest/rdd-programming-guide.html#resilient-distributed-datasets-rdds">Resilient Distributed Datasets</a>), <code>Dataframes</code> and <code>Datasets</code>.</p>
<p>The <code>RDD</code> is an immutable, distributed typed collection of objects. The <code>RDD</code> is partitioned across the cluster. This allows the spark operations, such as function mapping, to be applied to each subset of the <code>RDD</code> in parallel at each partition.</p>
<p><img src="./images/als/RDD.png" alt="" /></p>
<p>For the streaming ALS application we will use <code>RDD</code>s to implement the algorithm. Spark's MLlib provides a collaborative filtering implementation based on the distributed batch ALS which we've covered previously. The API is quite simple and to train a model we need:</p>
<pre style="background-color:#fff"><span style="color:#000;font-weight:bold">val</span> model <span style="color:#000;font-weight:bold">=</span> <span style="color:#458;font-weight:bold">ALS</span><span style="color:#000;font-weight:bold">.</span>train<span style="color:#000;font-weight:bold">(</span>ratings<span style="color:#000;font-weight:bold">,</span> rank<span style="color:#000;font-weight:bold">,</span> iterations<span style="color:#000;font-weight:bold">,</span> lambda<span style="color:#000;font-weight:bold">)</span>

<span style="color:#000;font-weight:bold">case</span> <span style="color:#000;font-weight:bold">class</span> <span style="color:#458;font-weight:bold">Rating</span><span style="color:#000;font-weight:bold">(</span>int user<span style="color:#000;font-weight:bold">,</span> int product<span style="color:#000;font-weight:bold">,</span> double rating<span style="color:#000;font-weight:bold">)</span>

<span style="color:#000;font-weight:bold">val</span> ratings<span style="color:#000;font-weight:bold">:</span> <span style="color:#458;font-weight:bold">RDD</span><span style="color:#000;font-weight:bold">[</span><span style="color:#458;font-weight:bold">Rating</span><span style="color:#000;font-weight:bold">]</span>
<span style="color:#000;font-weight:bold">val</span> rank<span style="color:#000;font-weight:bold">:</span> <span style="color:#458;font-weight:bold">int</span>
<span style="color:#000;font-weight:bold">val</span> iterations<span style="color:#000;font-weight:bold">:</span> <span style="color:#458;font-weight:bold">int</span>
<span style="color:#000;font-weight:bold">val</span> lambda<span style="color:#000;font-weight:bold">:</span> <span style="color:#458;font-weight:bold">Double</span>
</pre><ul>
<li>An <code>RDD</code> containing the ratings. The <code>RDD</code> has elements of the class <code>Rating</code>, which is basically a wrapper around a tuple of user id, product id and rating. This <code>RDD</code> corresponds to all the entries in our ratings matrix used previously.</li>
<li>The rank which corresponds to the number of elements in our latent factor vectors (this would be the number of columns or rows in our <span class="math inline">\(\mathsf{U}\)</span> and <span class="math inline">\(\mathsf{P}\)</span> matrices).</li>
<li>A stopping criteria in terms of iterations for the ALS.</li>
<li>And finally, we set the <code>lambda</code> parameter, a regularisation parameter, which we've shown to be a part of the loss function's regularisation.</li>
</ul>
<p>Since we have the data, the question is then how to choose the parameters. A typical method is to split the original ratings data into two random sets, one for training and one for validation. We then proceed to train the model to several different parameters, usually according to a grid search, and calculate some error measure between the predicted and validation ratings, choosing the parameters which minimise the error.</p>
<p>Once the model is trained, we get a <code>MatrixFactorizationModel</code> instance, which is basically a wrapper for the latent factors as <code>RDD</code>s.</p>
<pre style="background-color:#fff"><span style="color:#000;font-weight:bold">val</span> model <span style="color:#000;font-weight:bold">=</span> <span style="color:#458;font-weight:bold">ALS</span><span style="color:#000;font-weight:bold">.</span>train<span style="color:#000;font-weight:bold">(</span>ratings<span style="color:#000;font-weight:bold">,</span> rank<span style="color:#000;font-weight:bold">,</span> iterations<span style="color:#000;font-weight:bold">,</span> lambda<span style="color:#000;font-weight:bold">)</span>

model<span style="color:#000;font-weight:bold">:</span> <span style="color:#458;font-weight:bold">MatrixFactorizationModel</span>

<span style="color:#000;font-weight:bold">class</span> <span style="color:#458;font-weight:bold">MatrixFactorizationModel</span> <span style="color:#000;font-weight:bold">{</span>

	<span style="color:#000;font-weight:bold">val</span> userFeatures<span style="color:#000;font-weight:bold">:</span> <span style="color:#458;font-weight:bold">RDD</span><span style="color:#000;font-weight:bold">[(</span><span style="color:#458;font-weight:bold">Int</span>, <span style="color:#458;font-weight:bold">Array</span><span style="color:#000;font-weight:bold">[</span><span style="color:#458;font-weight:bold">Double</span><span style="color:#000;font-weight:bold">])]</span>
	<span style="color:#000;font-weight:bold">val</span> productFeatures<span style="color:#000;font-weight:bold">:</span> <span style="color:#458;font-weight:bold">RDD</span><span style="color:#000;font-weight:bold">[(</span><span style="color:#458;font-weight:bold">Int</span>, <span style="color:#458;font-weight:bold">Array</span><span style="color:#000;font-weight:bold">[</span><span style="color:#458;font-weight:bold">Double</span><span style="color:#000;font-weight:bold">])]</span>

<span style="color:#000;font-weight:bold">}</span>
</pre><p>One we have the trained model, we can now perform predictions.</p>
<h3 id="streaming-data">Streaming data</h3>
<p>We now want to build a streaming recommender system. For this scenario, we will assume that the observations take the form of a Spark's <em>Discretised Stream</em> or <a href="https://spark.apache.org/docs/latest/streaming-programming-guide.html#discretized-streams-dstreams">DStream</a>. With DStreams we consume the stream as mini-batches of <code>RDD</code>s over a certain interval window.</p>
<p><img src="./images/als/dstream.png" alt="" /></p>
<p>We can for instance, use the first mini-batch to initialise the model and the following batches to continuously train the model.</p>
<p>One immediate advantage of using observations as a stream is that we no longer need to keep the entirety of the data in memory or read it from storage. If we consider the batch implementation with a very large dataset if we had a single new observation and wanted to retrain the model, we would have to, for instance, read several million ratings from a database. With a streaming variant we can use that single observation to update the latent factors.</p>
<p>We will try to recreate Spark's batch ALS API by allowing model training using a ratings <code>RDD</code>, however this time, we consume each <code>RDD</code> from the stream mini-batch and will incrementally train the model as observations trickle in.</p>
<p><img src="./images/als/dstream%5Cals.png" alt="" /></p>
<p>First, we start by establishing the quantities and data structures needed to implement streaming ALS.</p>
<p>We've seen in the previous slides that the recursions for the gradient calculation take the following form, here presented in pseudo-code:</p>
<pre style="background-color:#fff">userBias <span style="color:#000;font-weight:bold">+=</span> gamma <span style="color:#000;font-weight:bold">*</span> (error <span style="color:#000;font-weight:bold">-</span> <span style="color:#000;font-weight:bold">lambda</span> \<span style="color:#000;font-weight:bold">*</span> userBias) 

userFeature(i) <span style="color:#000;font-weight:bold">+=</span> gamma <span style="color:#000;font-weight:bold">*</span> (error   prodFeature(j) <span style="color:#000;font-weight:bold">-</span> <span style="color:#000;font-weight:bold">lambda</span> <span style="color:#000;font-weight:bold">*</span> userFeature(i))
</pre><p>We create a <code>Factor</code> class to encapsulate the features and the corresponding bias.</p>
<p>We recall that in the Spark ALS implementation, the features were stored in <code>RDD</code>s typed as a tuple of <code>(id, Array)</code>, where now we have an equivalent form of <code>(id, Factor)</code> which allows us to capture the bias. I'll now provide a quick overview of the steps required to go from the initial ratings stream to the trained model, in terms of Spark's <code>RDD</code> operations.</p>
<p>Similarly to Spark's ALS, we can assume that the model data will be in the form of <code>Rating</code>'s <code>RDD</code>s. These, as we've seen, will correspond to a mini-batch of ratings from our data stream. We first need to create the initial user and product latent factors for the observed data and we would start by creating two separate <code>RDD</code>s from the data, one keyed by user id, the other by product id.</p>
<p><img src="./images/als/stream%5Cals%5Cstep%5C1.png" alt="" /></p>
<p>For each entry of those new <code>RDD</code>s (the user and product indexed ones) we will now generate a random vector of features. This can be done by simply filling a vector of size <code>rank</code> with random uniform values, but as you will recall, we now also have a bias associated with each entry, which will initially also be set to a random value.</p>
<p><img src="./images/als/stream%5Cals%5Cstep%5C2.png" alt="" /></p>
<p>We now join the incoming ratings, with the generated user factors (using the user id as the key) getting a resulting <code>RDD</code> consisting of product ids, user ids, ratings and user factors (and the same thing for products and product factors).</p>
<p><img src="./images/als/stream%5Cals%5Cstep%5C3.png" alt="" /></p>
<p>Finally, we have these two joint <code>RDD</code>s which have all the necessary quantities needed to calculate the partial gradient in each element. Recalling how to calculate a predicted rating in streaming ALS, we need the global bias, the user and product bias and the corresponding user and product latent vectors.</p>
<p>This is straightforward to calculate for each element as we can see from the pseudo-code.</p>
<p>Here the <code>dot</code> function is simply a function to calculate the dot product treating the two factor arrays as vectors.</p>
<p><span class="math display">\[\hat{\mathsf{R}}_{x,y}=\mu + b_x + b_y + \mathsf{U}_x^T \cdot \mathsf{P}_y
\]</span></p>
<pre style="background-color:#fff">prediction <span style="color:#000;font-weight:bold">=</span> dot<span style="color:#000;font-weight:bold">(</span>userFactors<span style="color:#000;font-weight:bold">.</span>features<span style="color:#000;font-weight:bold">,</span> itemFactors<span style="color:#000;font-weight:bold">.</span>features<span style="color:#000;font-weight:bold">)</span> <span style="color:#000;font-weight:bold">+</span> userFactors<span style="color:#000;font-weight:bold">.</span>bias <span style="color:#000;font-weight:bold">+</span> itemFactors<span style="color:#000;font-weight:bold">.</span>bias <span style="color:#000;font-weight:bold">+</span> bias
</pre><p>Given the prediction, the error is also straightforward to calculate, since the real rating is also included in this <code>RDD</code>.</p>
<p><span class="math display">\[\epsilon_{x,y} = \mathsf{R}_{x,y} - \hat{\mathsf{R}}_{x,y}
\]</span></p>
<pre style="background-color:#fff">eps <span style="color:#000;font-weight:bold">=</span> rating <span style="color:#000;font-weight:bold">-</span> prediction
</pre><p>And now, since we have the error, we can also easily calculate the update term for the user and product features. As mentioned previously, <code>gamma</code> and <code>lambda</code> are known model parameters which we pick ourselves when instantiating the streaming ALS algorithm.</p>
<p><span class="math display">\[\gamma \left(\epsilon_{x,y}\mathsf{U}_x-\lambda^{\prime}\mathsf{P}_y\right)
\]</span></p>
<pre style="background-color:#fff"><span style="color:#000;font-weight:bold">(</span><span style="color:#099">0</span> until rank<span style="color:#000;font-weight:bold">).</span>map <span style="color:#000;font-weight:bold">{</span> i <span style="color:#000;font-weight:bold">=&gt;</span> 
	gamma <span style="color:#000;font-weight:bold">*</span> <span style="color:#000;font-weight:bold">(</span>eps <span style="color:#000;font-weight:bold">*</span> userFactors<span style="color:#000;font-weight:bold">.</span>features<span style="color:#000;font-weight:bold">(</span>i<span style="color:#000;font-weight:bold">)</span> <span style="color:#000;font-weight:bold">-</span> lambda <span style="color:#000;font-weight:bold">*</span> itemFactors<span style="color:#000;font-weight:bold">.</span>features<span style="color:#000;font-weight:bold">(</span>i<span style="color:#000;font-weight:bold">))</span>
<span style="color:#000;font-weight:bold">}</span>
</pre><p>Finally, we update the user and product biases given the model parameters and the previous bias.</p>
<p><span class="math display">\[\gamma \left(\epsilon_{x,y}-\lambda_y b_y\right)
\]</span></p>
<pre style="background-color:#fff">gamma <span style="color:#000;font-weight:bold">*</span> <span style="color:#000;font-weight:bold">(</span>eps <span style="color:#000;font-weight:bold">-</span> lambda <span style="color:#000;font-weight:bold">*</span> itemFactors<span style="color:#000;font-weight:bold">.</span>bias<span style="color:#000;font-weight:bold">)</span>
</pre><p>These calculated gradients can now be mapped to a new <code>RDD</code> which we will use to update the final biases and latent factors.</p>
<p>The last step is to split the gradients according to user and product, and finally, when in possession of all the individual gradients, we reduce them into latent factors by performing an aggregated sum for each user and product.</p>
<p>So these steps define the entirety of the streaming ALS operation. For each observation window, we calculate the latent factors <code>RDD</code>, and on the following window we update these factors, given the current observations.</p>
<p>We've covered the initialisation case, that is, we assumed the case where the model is not initialised and we received the first mini-batch of ratings. If, on the following window, we receive ratings for previously unseen user or products, the procedure is exactly the same, that is, we generate random factors and update as described.</p>
<p><img src="./images/als/stream%5Cals%5Coverview.png" alt="" /></p>
<p>Now I'll just quickly cover the case where we get some ratings from users or for some product we've already seen. For this new set of observations, we proceed exactly as previously, that is, we split the data into separate <code>RDD</code>s, each one containing the ratings but keyed by user and product id. I'll assume that we get a mixture of completely new data, that is, unseen user and products and some ratings for previously seen users and products shown in red.</p>
<p><img src="./images/als/stream%5Cals%5Cpost%5Cstep%5C1.png" alt="" /></p>
<p>The difference now is that, instead of assigning random factors and biases to each entry of these <code>RDD</code>s, we perform a full outer join between them and the current latent factors.</p>
<p>The strategy is then to keep the matching existing latent factor and create random features and biases just for the user and product entries we haven't seen before.</p>
<p>Now that we are in possession of this joint <code>RDD</code>, we can apply exactly the same steps as previously to update the factors and repeat these steps for all future incoming observations, allowing us to continuously update the model.</p>
<p>It is now easy to see that, in the limit situation where we only have one new rating, we would now only have to update a single entry of the latent factors <code>RDD</code>, in contrast with the batch method, where the entirety of the factors would be used in the ALS step.</p>
<p><img src="./images/als/stream%5Cals%5Cpost%5Cstep%5C2.png" alt="" /></p>
<p>Let's look at some results comparing the streaming implementation with the Spark's batch implementation.</p>
<p>The dataset we have chosen to use in these tests is one of the <a href="https://grouplens.org/datasets/movielens/latest/">MovieLens' datasets</a>. These dataset are a widely used data in recommendation engine research. They are managed by the Lens corporation and are freely available for non-commercial applications.</p>
<p>These datasets come in several variants, namely a <a href="http://files.grouplens.org/datasets/movielens/ml-latest-small-README.html">small</a> variant, useful for a quick algorithm prototyping and testing, and a <a href="http://files.grouplens.org/datasets/movielens/ml-latest-README.html">full</a> variant, with approximately 26 million ratings (from 45,000 movies and 270,000 users), useful for a more comprehensive testing and benchmark.</p>
<p>The data is available as a set of Comma Separated Value files, each containing different variables, but we are mainly interested in the <code>ratings</code> file which contains four variables: a unique user and movie id, represented as integers, a rating represented by a value from 0 to 5 with steps of 0.5 and a timestamp for when the movie was rated by this user.</p>
<p>First, we'll start by training a batch ALS model using the MovieLens data. We assume that we already have the observations as an <code>RDD</code> of ratings and simply split the data into 80% for training and 20% for validation.</p>
<pre style="background-color:#fff"><span style="color:#000;font-weight:bold">val</span> split<span style="color:#000;font-weight:bold">:</span> <span style="color:#458;font-weight:bold">Array</span><span style="color:#000;font-weight:bold">[</span><span style="color:#458;font-weight:bold">RDD</span><span style="color:#000;font-weight:bold">[</span><span style="color:#458;font-weight:bold">Rating</span><span style="color:#000;font-weight:bold">]]</span> <span style="color:#000;font-weight:bold">=</span> ratings<span style="color:#000;font-weight:bold">.</span>randomSplit<span style="color:#000;font-weight:bold">(</span><span style="color:#099">0.8</span><span style="color:#000;font-weight:bold">,</span> <span style="color:#099">0.2</span><span style="color:#000;font-weight:bold">)</span>

<span style="color:#000;font-weight:bold">val</span> model <span style="color:#000;font-weight:bold">=</span> <span style="color:#458;font-weight:bold">ALS</span><span style="color:#000;font-weight:bold">.</span>train<span style="color:#000;font-weight:bold">(</span>split<span style="color:#000;font-weight:bold">(</span><span style="color:#099">0</span><span style="color:#000;font-weight:bold">),</span> rank<span style="color:#000;font-weight:bold">,</span> iter<span style="color:#000;font-weight:bold">,</span> lambda<span style="color:#000;font-weight:bold">)</span>
</pre><p>Here, we won't show the steps to determine the best parameters for this dataset, were we performed a simple parameter grid search over a number of possible candidates. The Spark ALS API is quite simple and to train the model we simply pass the training <code>RDD</code> and the parameters.</p>
<p>We can now use the remaining 20% of the observations to calculate the RMSE between the model predictions and the actual ratings.</p>
<p>We now can persist the validation <code>RDD</code>, so we can use the exact same one for the streaming ALS run.</p>
<pre style="background-color:#fff"><span style="color:#000;font-weight:bold">val</span> predictions<span style="color:#000;font-weight:bold">:</span> <span style="color:#458;font-weight:bold">RDD</span><span style="color:#000;font-weight:bold">[</span><span style="color:#458;font-weight:bold">Rating</span><span style="color:#000;font-weight:bold">]</span> <span style="color:#000;font-weight:bold">=</span> model
	<span style="color:#000;font-weight:bold">.</span>predict<span style="color:#000;font-weight:bold">(</span>split<span style="color:#000;font-weight:bold">(</span><span style="color:#099">1</span><span style="color:#000;font-weight:bold">).</span>map <span style="color:#000;font-weight:bold">{</span> 
		x <span style="color:#000;font-weight:bold">=&gt;(</span>x<span style="color:#000;font-weight:bold">.</span>user<span style="color:#000;font-weight:bold">,</span> x<span style="color:#000;font-weight:bold">.</span>product<span style="color:#000;font-weight:bold">))</span>
	<span style="color:#000;font-weight:bold">}</span>

<span style="color:#000;font-weight:bold">val</span> pairs <span style="color:#000;font-weight:bold">=</span> predictions
	<span style="color:#000;font-weight:bold">.</span>map<span style="color:#000;font-weight:bold">(</span>x <span style="color:#000;font-weight:bold">=&gt;</span> <span style="color:#000;font-weight:bold">((</span>x<span style="color:#000;font-weight:bold">.</span>user<span style="color:#000;font-weight:bold">,</span> x<span style="color:#000;font-weight:bold">.</span>product<span style="color:#000;font-weight:bold">),</span> x<span style="color:#000;font-weight:bold">.</span>rating<span style="color:#000;font-weight:bold">))</span>
	<span style="color:#000;font-weight:bold">.</span>join<span style="color:#000;font-weight:bold">(</span>
		split<span style="color:#000;font-weight:bold">(</span><span style="color:#099">1</span><span style="color:#000;font-weight:bold">)</span>
			<span style="color:#000;font-weight:bold">.</span>map<span style="color:#000;font-weight:bold">(</span>x <span style="color:#000;font-weight:bold">=&gt;</span> <span style="color:#000;font-weight:bold">((</span>x<span style="color:#000;font-weight:bold">.</span>user<span style="color:#000;font-weight:bold">,</span> x<span style="color:#000;font-weight:bold">.</span>product<span style="color:#000;font-weight:bold">),</span> x<span style="color:#000;font-weight:bold">.</span>rating<span style="color:#000;font-weight:bold">))</span>
	<span style="color:#000;font-weight:bold">.</span>values

<span style="color:#000;font-weight:bold">val</span> <span style="color:#458;font-weight:bold">RMSE</span> <span style="color:#000;font-weight:bold">=</span> math<span style="color:#000;font-weight:bold">.</span>sqrt<span style="color:#000;font-weight:bold">(</span>
	pairs<span style="color:#000;font-weight:bold">.</span>map<span style="color:#000;font-weight:bold">(</span>x <span style="color:#000;font-weight:bold">=&gt;</span> math<span style="color:#000;font-weight:bold">.</span>pow<span style="color:#000;font-weight:bold">(</span>x<span style="color:#000;font-weight:bold">.</span>_1 <span style="color:#000;font-weight:bold">-</span> x<span style="color:#000;font-weight:bold">.</span>_2<span style="color:#000;font-weight:bold">,</span> <span style="color:#099">2</span><span style="color:#000;font-weight:bold">)).</span>mean<span style="color:#000;font-weight:bold">())</span>
</pre><p>In order to test the streaming version, we first need to define a data source. We start with the original MovieLens data and remove all the ratings from the validation observations.</p>
<p>We then create a simulated stream of observations using <a href="https://kafka.apache.org/">Kafka</a>, with an interval of 5 seconds and with 1000 observations in each mini-batch. These are arbitrary numbers, chosen just for practical reasons. We could have, for instance, a single observation in each mini-batch.</p>
<p>It is not guaranteed that the best parameters (namely <code>rank</code> and <code>lambda</code>) chosen for the batch version are the best for the streaming implementation, however we've decided to use the same ones. For each mini-batch we then incrementally train the model and calculate the RMSE up to that point. Given the actual ratings in the validation set and the model's prediction, the RMSE calculation is the same as in the batch version. And looking at the results, we can see that with each mini-batch (of 1000 observations), the RMSE from the streaming version (in blue) is edging towards the batch value (plotted as the horizontal dashed line).</p>
<p><img src="./images/als/mse_comparison.png" alt="" /></p>
<h3 id="caveats">Caveats</h3>
<p>However, streaming ALS has pitfalls which we have to take into account.</p>
<h4 id="cold-start">Cold start</h4>
<p>An issue, which is shared with batch ALS, is usually called the <em>cold start</em> problem. This refers to initial point in a recommender engine where we have too few observations to make meaningful predictions. As we now know, when having a small number of ratings, since our latent factors are initialised to random numbers, most of our predicted ratings will also be random.</p>
<p>Although this is not an exclusive problem to the streaming implementation, we might be tempted, since the system is suited for realtime recommendations, to immediately start serving predictions. It might be wise to exercise caution and train the model offline with a larger dataset or at least perform some model diagnostics to check how sensible our predictions are.</p>
<h4 id="hyperparameter-estimation">Hyperparameter estimation</h4>
<p>Another challenge we encounter is hyperparameter estimation.</p>
<p>In the batch ALS case, we can perform a grid search for instance and estimate the hyperparameters. If, after some time, we find ourselves with a new ratings or even new product and users, we can simply repeat this procedure using the totality of the data. As an example, if in batch ALS at any point we wish to estimate the model with a different rank, this would be perfectly acceptable.</p>
<p><img src="./images/als/hyperparameters.png" alt="" /></p>
<p>In the streaming case, we can't do that. When we have a new batch of observations, we assume that previous ones were discarded since they are already incorporated in the latent factors. If they weren't and we keep all the observations in the stream, we might as well use batch ALS.</p>
<p><img src="./images/als/hyperparameters_2.png" alt="" /></p>
<p>A solution is to perform a grid search in parallel from the start and prune the least performant models as time progresses. This has the disadvantage of being expensive in terms of resources, since we have to keep several models simultaneously and again, we have the cold start problem surfacing.</p>
<p>This means that we have no guarantee that the best parameters for a initial batch with few observations will still be the best further on.</p>
<p><img src="./images/als/hyperparameters_3.png" alt="" /></p>
<h4 id="performance">Performance</h4>
<p>Also, there are some performance considerations. As we've seen, we implement some operations which can be costly in a Spark setting. We have several join operations which can lead to a considerable amount of data shuffling between partitions.</p>
<p>Care must be taken into choosing an appropriate partitioning strategy to minimise data shuffling.</p>
<p>Spark's implementation of batch ALS uses a specific method called blocked ALS, which computes outgoing and ingoing links between user and products vectors and then partitioning them in blocks in order to minimise data transfer between nodes.</p>
<p><img src="./images/als/partitioning.png" alt="" /></p>
<p>Also, to make predictions we might have to try and perform random access to the latent factors <code>RDDs</code>. This also can be quite inefficient since we are using <code>lookup</code> methods.</p>
<p>If you want to get straight setting up your own distributed recommendation engine, I highly suggest you start with Spark's builtin solution. I would highly recommended looking at the <code>jiminy</code> project (part of the <a href="https://radanalytics.io/">radanalytics.io</a> community), a micro-service oriented complete recommendation engine, ready to deploy on <a href="https://www.openshift.com/">OpenShift</a>.</p>
<p>The engine is split into services such as a <a href="https://github.com/radanalyticsio/jiminy-predictor">predictor</a> and a <a href="https://github.com/radanalyticsio/jiminy-modeler">modeler</a>, along with a <a href="https://github.com/radanalyticsio/jiminy-html-server">front-end</a> and <a href="https://github.com/radanalyticsio/jiminy-tools">tools</a> to simplify tasks (such as using the MovieLens data) and it's a great way to look at how to put a modern recommender engine together and also a great code read.</p>

    <div class="footer">
        <span class="cc-symbol">&#127341;</span> 2020 CC BY Rui Vieira
    </div>
</div>

</body>
</html>